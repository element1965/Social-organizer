generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Platform {
  FACEBOOK
  TELEGRAM
  APPLE
  GOOGLE
}

enum UserRole {
  REGULAR
  AUTHOR
  DEVELOPER
}

enum Theme {
  LIGHT
  DARK
  SYSTEM
}

enum VoiceGender {
  MALE
  FEMALE
}

enum CollectionType {
  EMERGENCY
  REGULAR
}

enum CollectionStatus {
  ACTIVE
  BLOCKED
  CLOSED
  CANCELLED
}

enum PendingConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum NotificationType {
  NEW_COLLECTION
  COLLECTION_BLOCKED
  COLLECTION_CLOSED
  NEW_OBLIGATION
  RE_NOTIFY
  SPECIAL_AUTHOR
  SPECIAL_DEVELOPER
  INVITE_ACCEPTED
}

enum SuggestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum NotificationStatus {
  UNREAD
  READ
  DISMISSED
  RESPONDED
  EXPIRED
}

model User {
  id                  String    @id @default(cuid())
  name                String
  email               String?   @unique
  passwordHash        String?
  bio                 String?
  phone               String?
  photoUrl            String?
  language            String    @default("en")
  theme               Theme     @default(SYSTEM)
  soundEnabled        Boolean     @default(true)
  voiceGender         VoiceGender @default(FEMALE)
  fontScale           Float       @default(1.0)
  hideContacts        Boolean     @default(false)
  role                UserRole  @default(REGULAR)
  onboardingCompleted Boolean   @default(false)
  onboardingReminderSent Int    @default(0)
  preferredCurrency   String    @default("USD")
  monthlyBudget       Float?
  remainingBudget     Float?
  budgetUpdatedAt     DateTime?
  referralSlug        String?   @unique
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  deletedAt           DateTime?
  lastSeen            DateTime?

  platformAccounts PlatformAccount[]
  connectionsFrom  Connection[]      @relation("connectionFromUser")
  connectionsTo    Connection[]      @relation("connectionToUser")
  collections      Collection[]
  obligations      Obligation[]
  notifications    Notification[]
  ignoreFrom       IgnoreEntry[]     @relation("ignoreFrom")
  ignoreTo         IgnoreEntry[]     @relation("ignoreTo")
  linkingCodes     LinkingCode[]
  invitesSent      InviteLink[]      @relation("inviter")
  invitesUsed      InviteLink[]      @relation("inviteUsedBy")
  contacts         UserContact[]
  chatMessages     ChatMessage[]
  faqItems         FaqItem[]
  pushSubscriptions PushSubscription[]
  pendingFrom      PendingConnection[] @relation("pendingFrom")
  pendingTo        PendingConnection[] @relation("pendingTo")
  skills           UserSkill[]
  needs            UserNeed[]
  skillsCompleted  Boolean   @default(false)
  city             String?
  countryCode      String?   @map("country_code")
  latitude         Float?
  longitude        Float?
  skillMatchNotifsReceived SkillMatchNotification[] @relation("skillMatchRecipient")
  skillMatchNotifsSent     SkillMatchNotification[] @relation("skillMatchActor")
  suggestedCategories      SuggestedCategory[]
  chainLinksAsGiver        MatchChainLink[]         @relation("chainGiver")
  chainLinksAsReceiver     MatchChainLink[]         @relation("chainReceiver")

  @@map("users")
}

model PlatformAccount {
  id           String   @id @default(cuid())
  userId       String
  platform     Platform
  platformId   String
  accessToken  String?
  refreshToken String?
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([platform, platformId])
  @@index([userId])
  @@map("platform_accounts")
}

model Connection {
  id          String   @id @default(cuid())
  userAId     String
  userBId     String
  nicknameByA String?
  nicknameByB String?
  createdAt   DateTime @default(now())

  userA User @relation("connectionFromUser", fields: [userAId], references: [id], onDelete: Cascade)
  userB User @relation("connectionToUser", fields: [userBId], references: [id], onDelete: Cascade)

  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
  @@map("connections")
}

model Collection {
  id                String           @id @default(cuid())
  creatorId         String
  type              CollectionType
  amount            Float?
  currency          String           @default("USD")
  originalAmount    Float?
  originalCurrency  String?
  chatLink          String
  status            CollectionStatus @default(ACTIVE)
  currentCycleStart DateTime?
  cycleNumber       Int              @default(1)
  blockedAt         DateTime?
  closedAt          DateTime?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  creator       User           @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  obligations   Obligation[]
  notifications Notification[]

  @@index([creatorId])
  @@index([status])
  @@map("collections")
}

model Obligation {
  id               String    @id @default(cuid())
  collectionId     String
  userId           String
  amount           Float
  originalAmount   Float?
  originalCurrency String?
  isSubscription   Boolean   @default(false)
  unsubscribedAt   DateTime?
  createdAt        DateTime  @default(now())

  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([collectionId])
  @@index([userId])
  @@map("obligations")
}

model Notification {
  id            String             @id @default(cuid())
  userId        String
  collectionId  String
  type          NotificationType
  handshakePath Json               @default("[]")
  status        NotificationStatus @default(UNREAD)
  expiresAt     DateTime
  wave          Int                @default(1)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([userId, collectionId, type, wave])
  @@index([userId, status])
  @@index([expiresAt])
  @@map("notifications")
}

model IgnoreEntry {
  id         String   @id @default(cuid())
  fromUserId String
  toUserId   String
  createdAt  DateTime @default(now())

  fromUser User @relation("ignoreFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User @relation("ignoreTo", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([fromUserId, toUserId])
  @@map("ignore_entries")
}

model LinkingCode {
  id        String   @id @default(cuid())
  userId    String
  code      String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([code, expiresAt])
  @@map("linking_codes")
}

model InviteLink {
  id        String   @id @default(cuid())
  inviterId String
  token     String   @unique
  usedById  String?
  createdAt DateTime @default(now())
  usedAt    DateTime?

  inviter  User  @relation("inviter", fields: [inviterId], references: [id], onDelete: Cascade)
  usedBy   User? @relation("inviteUsedBy", fields: [usedById], references: [id])

  @@index([token])
  @@map("invite_links")
}

model UserContact {
  id        String   @id @default(cuid())
  userId    String
  type      String   // telegram, whatsapp, facebook, instagram, twitter, linkedin, vk, email, website
  value     String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
  @@index([userId])
  @@map("user_contacts")
}

model ChatMessage {
  id               String   @id @default(cuid())
  userId           String
  userMessage      String
  assistantMessage String
  isFeedback       Boolean  @default(false)
  language         String   @default("en")
  createdAt        DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isFeedback])
  @@index([createdAt])
  @@map("chat_messages")
}

model PushSubscription {
  id        String   @id @default(cuid())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscriptions")
}

model PendingConnection {
  id          String                  @id @default(cuid())
  fromUserId  String
  toUserId    String
  status      PendingConnectionStatus @default(PENDING)
  resolvedAt  DateTime?
  createdAt   DateTime                @default(now())

  fromUser User @relation("pendingFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User @relation("pendingTo", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([fromUserId, toUserId])
  @@index([toUserId, status])
  @@index([fromUserId, status])
  @@map("pending_connections")
}

enum ScheduledPostStatus {
  PENDING
  SENT
  CANCELLED
  FAILED
}

model ScheduledPost {
  id           String              @id @default(cuid())
  text         String
  mediaType    String              @default("text")
  mediaUrl     String?
  mediaFileId  String?
  buttonUrl    String?
  buttonText   String?
  scheduledAt  DateTime
  status       ScheduledPostStatus @default(PENDING)
  sentAt       DateTime?
  sentCount    Int?
  errorMessage String?
  createdById  String
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  deliveries   ScheduledPostDelivery[]
  @@index([status, scheduledAt])
  @@map("scheduled_posts")
}

model ScheduledPostDelivery {
  id     String    @id @default(cuid())
  postId String
  userId String
  sentAt DateTime  @default(now())
  readAt DateTime?
  post   ScheduledPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  @@unique([postId, userId])
  @@index([userId, readAt])
  @@map("scheduled_post_deliveries")
}

model AutoChainMessage {
  id          String   @id @default(cuid())
  text        String
  mediaType   String   @default("text")
  mediaUrl    String?
  mediaFileId String?
  buttonUrl   String?
  buttonText  String?
  dayOffset   Int
  sortOrder   Int      @default(0)
  intervalMin Int      @default(120)
  variant     String   @default("all")
  isActive    Boolean  @default(true)
  sentCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deliveries  AutoChainDelivery[]
  @@index([isActive, dayOffset, sortOrder])
  @@map("auto_chain_messages")
}

model AutoChainDelivery {
  id        String    @id @default(cuid())
  messageId String
  userId    String
  sentAt    DateTime  @default(now())
  readAt    DateTime?
  success   Boolean   @default(true)
  message   AutoChainMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  @@unique([messageId, userId])
  @@index([userId, readAt])
  @@map("auto_chain_deliveries")
}

model FaqItem {
  id          String   @id @default(cuid())
  question    String
  answer      String
  imageUrl    String?
  language    String   @default("ru")
  sortOrder   Int      @default(0)
  viewCount   Int      @default(0)
  groupId     String?
  isLocalized Boolean  @default(false)
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  createdBy User @relation(fields: [createdById], references: [id], onDelete: Cascade)

  @@index([language, sortOrder])
  @@index([groupId])
  @@map("faq_items")
}

model BotStart {
  id           String   @id @default(cuid())
  chatId       String   @unique
  name         String?
  language     String   @default("en")
  inviteToken  String?
  reminderSent Int      @default(0)
  createdAt    DateTime @default(now())

  @@map("bot_starts")
}

model TranslationCache {
  id         String   @id @default(cuid())
  sourceHash String
  language   String
  translated String
  createdAt  DateTime @default(now())

  @@unique([sourceHash, language])
  @@map("translation_cache")
}

model SkillCategory {
  id        String   @id @default(cuid())
  key       String   @unique
  group     String
  sortOrder Int      @default(0)
  isOnline  Boolean  @default(false)
  createdAt DateTime @default(now())

  skills              UserSkill[]
  needs               UserNeed[]
  matchNotifications  SkillMatchNotification[]
  suggestedCategories SuggestedCategory[]
  chainLinks          MatchChainLink[]

  @@index([group, sortOrder])
  @@map("skill_categories")
}

model UserSkill {
  id         String   @id @default(cuid())
  userId     String
  categoryId String
  note       String?
  createdAt  DateTime @default(now())

  user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  category SkillCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([userId, categoryId])
  @@index([userId])
  @@index([categoryId])
  @@map("user_skills")
}

model UserNeed {
  id         String   @id @default(cuid())
  userId     String
  categoryId String
  note       String?
  createdAt  DateTime @default(now())

  user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  category SkillCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([userId, categoryId])
  @@index([userId])
  @@index([categoryId])
  @@map("user_needs")
}

model SkillMatchNotification {
  id          String             @id @default(cuid())
  userId      String
  matchUserId String
  categoryId  String
  status      NotificationStatus @default(UNREAD)
  createdAt   DateTime           @default(now())

  user      User          @relation("skillMatchRecipient", fields: [userId], references: [id], onDelete: Cascade)
  matchUser User          @relation("skillMatchActor", fields: [matchUserId], references: [id], onDelete: Cascade)
  category  SkillCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([userId, matchUserId, categoryId])
  @@index([userId, status])
  @@map("skill_match_notifications")
}

model SuggestedCategory {
  id         String        @id @default(cuid())
  userId     String
  group      String
  text       String
  status     SuggestStatus @default(PENDING)
  categoryId String?
  createdAt  DateTime      @default(now())
  reviewedAt DateTime?

  user     User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  category SkillCategory? @relation(fields: [categoryId], references: [id])

  @@index([status])
  @@map("suggested_categories")
}

enum ChainStatus {
  PROPOSED
  ACTIVE
  COMPLETED
  CANCELLED
}

model MatchChain {
  id              String      @id @default(cuid())
  status          ChainStatus @default(PROPOSED)
  length          Int
  telegramChatUrl String?
  chatAddedBy     String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  links MatchChainLink[]

  @@index([status])
  @@map("match_chains")
}

model MatchChainLink {
  id               String  @id @default(cuid())
  chainId          String
  position         Int
  giverId          String
  receiverId       String
  categoryId       String
  offerHours       Float?
  offerDescription String?
  giverConfirmed   Boolean @default(false)
  receiverConfirmed Boolean @default(false)
  giverCompleted   Boolean @default(false)
  receiverCompleted Boolean @default(false)

  chain    MatchChain    @relation(fields: [chainId], references: [id], onDelete: Cascade)
  giver    User          @relation("chainGiver", fields: [giverId], references: [id], onDelete: Cascade)
  receiver User          @relation("chainReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  category SkillCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([chainId, position])
  @@index([giverId])
  @@index([receiverId])
  @@map("match_chain_links")
}
